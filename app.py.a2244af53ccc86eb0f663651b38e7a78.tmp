import os
from datetime import datetime
import json
from re import X
import datetime
import random
from math import*
from googlesearch import search
import os
from function import*
import sys


from flask import Flask, abort, g, request

# https://github.com/line/line-bot-sdk-python
from linebot import LineBotApi, WebhookHandler
from linebot.exceptions import InvalidSignatureError
from linebot.models import (MessageEvent,
                            TextMessage,
                            AudioMessage,
                            ImageMessage,
                            TextSendMessage,
                            ImageSendMessage,
                            VideoSendMessage,
                            AudioSendMessage,
                            LocationSendMessage,
                            StickerSendMessage,
                            ImagemapSendMessage,
                            TemplateSendMessage,
                            FlexSendMessage,
                            ButtonsTemplate,
                            MessageTemplateAction,
                            PostbackEvent,
                            PostbackTemplateAction)

send_headers = {
    "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari/537.36",
    "Connection": "keep-alive",
    "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8",
    "Accept-Language": "zh-CN,zh;q=0.8"}

app = Flask(__name__)

# os.system('python3 -m playwright install')
os.system('apt-get install sudo')
os.system('sudo apt-get update')
os.system('sudo apt install ffmpeg -y')

# get channel_secret and channel_access_token from your environment variable

channel_secret = os.getenv('LINE_CHANNEL_SECRET', None)
channel_access_token = os.getenv('LINE_CHANNEL_ACCESS_TOKEN', None)

if channel_secret is None:
    print('Specify LINE_CHANNEL_SECRET as environment variable.')
    sys.exit(1)

if channel_access_token is None:
    print('Specify LINE_CHANNEL_ACCESS_TOKEN as environment variable.')
    sys.exit(1)

line_bot_api = LineBotApi(channel_access_token)
handler = WebhookHandler(channel_secret)


Message_counter = 0
Message_container = ''
previous_user_name = ''


@app.route("/", methods=["GET", "POST"])
def callback():

    if request.method == "GET":
        return "Hello"
    if request.method == "POST":
        signature = request.headers["X-Line-Signature"]
        body = request.get_data(as_text=True)

        try:
            handler.handle(body, signature)
        except InvalidSignatureError:
            abort(400)

        return "OK"


@handler.add(MessageEvent, message=TextMessage)
def handle_message(event):
    dt = (datetime.datetime.today() +
          datetime.timedelta(hours=8)).strftime("%Y/%m/%d")
    print(dt)

    get_message = event.message.text.rstrip()
    get_message = get_message.replace('ï¼', '!')
    l_get_message = get_message.strip()
    split = get_message.split()

    id = event.source.user_id
    owner = 'U2290158f54f16aea8c2bdb597a54ff9e'
    try:
        group_id = event.source.group_id
    except:
        group_id = 'N/A'
    group = 'C0862e003396d3da93b9016d848560f29'

    line_bot_api = LineBotApi(channel_access_token)
    try:
        profile = line_bot_api.get_group_member_profile(
            group_id, id)
    except:
        profile = line_bot_api.get_profile(id)
    user_name = profile.display_name

    global Message_counter
    global Message_container
    global previous_user_name
    if Message_container == get_message:
        Message_counter += 1
    else:
        Message_counter = 1
        Message_container = get_message

    # Send To Line
    print(user_name+id)

    if group_id == group:
        F_countMSG(event)

    if id == owner:
        if split[0] == '!bully':
            F_bullyManager(split, event)

    with open('json/setting.json', 'r', encoding='utf8') as jfile:
        jdata = json.load(jfile)

    # if split[0].lower() == '!gpt':
    #     F_chatGPT(get_message, event)

    if split[0].lower() == '!t':
        F_translate(get_message, split, event)

    if split[0].lower() == '!tts':
        F_TTS(get_message, event)

    if get_message[0].isdigit() and get_message[-1].isdigit():
        F_eval(get_message, event)

    if get_message == '!irin':
        random_pic = random.choice(jdata['irin_pic'])
        img_reply(random_pic, event)

    if get_message == '!åˆ‘å®‰':
        print(event)
        random_pic = random.choice(jdata['åˆ‘å®‰_pic'])
        img_reply(random_pic, event)

    if get_message == '!æŠ½å¡':
        n = random.randint(1, 3)
        if n == 1:
            img_reply(
                'https://cdn.discordapp.com/attachments/856516846144192543/866531135126110248/14419370570913.jpg', event)
        elif n == 2:
            img_reply(
                'https://media.discordapp.net/attachments/856516846144192543/1069646767248920590/S__31596567.jpg', event)
        elif n == 3:
            text_reply('''
            -1200ğŸ’

            âœ‰ï¸
            ğŸ™Œ
            ğŸ˜†

            ğŸ“„

            ğŸ“˜ ğŸ“˜ ğŸ“˜ ğŸ“˜ ğŸ“˜
            ğŸ“˜ ğŸ“˜ ğŸ“˜ ğŸ“˜ ğŸ“’
            x1ğŸ”® x1ğŸ”® x1ğŸ”® x1ğŸ”® x1ğŸ”®
            x1ğŸ”® x1ğŸ”® x1ğŸ”® x1ğŸ”® x10ğŸ”®
            ''')


    if get_message[:2] == '!æŠ½':
        F_lottery(jdata, group_id, split, event)

    if '.jpg' in get_message.lower() or '.png' in get_message.lower():
        F_imgSearch(split, jdata, get_message, event)

    if get_message[:3].lower() == '!yt':
        F_ytSearch(split, get_message, jdata, event)

    if get_message[:2].lower() == '!s' or get_message[:4] == 'æœ‰äººçŸ¥é“' or (get_message[:1] == 'æ•™' and get_message[-1:] == 'å—' and len(get_message) > 2):
        F_GoogleSearch(get_message, event)

    if get_message[:26] == 'https://www.instagram.com/':
        pass

    if split[0] == '!tmr':
        F_tmr(send_headers, split, event)

    if get_message[:3].lower() == '!nh':
        F_nh(split, get_message, event)

    if get_message == '!æˆ´ç”·':
        rand_voice = random.choice(jdata['dai_voice'])
        audio_reply(rand_voice, event)

    if get_message[:5] == '!echo':
        text_reply(get_message[6:], event)

    elif get_message[:4] != 'http':

        if 'æ©Ÿå™¨äºº' in get_message or 'bot' in get_message:
            for i in jdata['abuse_words']:
                if i in get_message:
                    text_reply(user_name+'å…‡ä¸‰å° å®¶è£¡æ­»äººå–” = =', event)
            for i in jdata['praise_words']:
                if i in get_message:
                    img_reply(
                        'https://cdn.discordapp.com/attachments/856516846144192543/863114640345923604/image0.png', event)

        for i in jdata['echo_words']:
            if i in get_message:
                if get_message[0] == 'æˆ‘':
                    get_message = get_message.replace('æˆ‘', 'ä½ ')
                if "ä¸æœƒ" not in get_message:
                    get_message = get_message.replace('æœƒ', 'æ‰æœƒ')
                if "æœƒä¸æœƒ" not in get_message:
                    get_message = get_message.replace('æœƒä¸æœƒ', 'æ‰æœƒ')
                if "ä½ æ˜¯" in get_message or "å¦³æ˜¯" in get_message:
                    get_message = get_message.replace('æ˜¯', 'æ‰æ˜¯')
                    get_message = get_message.replace('æ‰æ˜¯ä¸æ‰æ˜¯', 'æ‰æ˜¯')
                text_reply(get_message, event)
                break

        for i in jdata['china_words']:
            if i in get_message:
                random_pic = random.choice(jdata['chPolice_pic'])
                img_reply(random_pic, event)
                break

        for i in jdata['full_echo_words']:
            if i == get_message:
                text_reply(get_message, event)
                break

        if 'è²·' in get_message:
            if 'æœƒå“¡' in get_message:
                text_reply('è²· æˆ‘å«ä½ è²·', event)

        if 'æˆ‘' in get_message:
            if 'ä¸æœƒ' in get_message and len(get_message) < 20:
                text_reply('å“ˆå“ˆä½ åˆä¸æœƒäº†', event)

        if 'æ•™å—' in get_message or 'æ•™å˜›' in get_message or 'æ•™ï¼Ÿ' in get_message or 'æ•™?' in get_message:
            text_reply('ä¸è¦å˜²è«·å¥½å—', event)

        if 'åŠ æ¨' in get_message or 'æˆ‘å©†' in get_message:
            text_reply('åˆï¼Ÿ', event)

        if 'ä¸€ç”Ÿ' in get_message and 'æ¨' in get_message and 'ä¸' not in get_message:
            text_reply(user_name+'ä½ çœŸå¯æ†', event)

    if l_get_message[:17] == 'https://youtu.be/' or l_get_message[:24] == 'https://www.youtube.com/' or l_get_message[:22] == "https://m.youtube.com/":
        F_ytPreview(l_get_message, jdata, event)

    if 'ptt' in get_message and 'ä¸å°å‡º' not in get_message:
        F_pttPreview(get_message, event)

    if 'twitter.com' in get_message:
        F_twitterPreview(get_message, event)

    if 'forum.gamer.com.tw' in get_message:
        F_bahamutePreview(get_message, event)

    if 'home.gamer.com.tw' in get_message:
        F_bahamuteHomePreview(get_message, event)

    if get_message[:5] == '!rand':
        F_randnum(get_message, event)

    if get_message[:5] == '!rate':
        F_rate(get_message, send_headers, event)

    # if l_get_message.lower() == '!od':
    #     F_objectDetect(event)

    if l_get_message.lower() == '!face':
        if group_id == 'N/A':
            F_faceDetect(event, id)
        else:
            F_faceDetect(event, group_id)

    if l_get_message.lower() == '!oppai':
        if group_id == 'N/A':
            F_oppaiDetect(event, id)
        else:
            F_oppaiDetect(event, group_id)

    if l_get_message.lower() == '!rbg':
        if group_id == 'N/A':
            F_removeBG(event, id)
        else:
            F_removeBG(event, group_id)

    if l_get_message.lower() == '!manga':
        if group_id == 'N/A':
            F_manga(event, id)
        else:
            F_manga(event, group_id)

    if l_get_message.lower() == '!img':
        if group_id == 'N/A':
            text_reply(uploadIMG(f"{id}.jpg"), event)
        else:
            text_reply(uploadIMG(f"{group_id}.jpg"), event)

    if get_message[:5].lower() == '!vote':
        F_vote(event)

    if get_message.lower() == '!history':
        F_history(event)

    if ('line' in get_message.lower() or 'è³´' in get_message) and 'æ€’' in get_message:
        with open('previous_user_name.txt', 'r') as f:
            previous_user_name = f.read()
        text_reply(f'@{previous_user_name} ğŸ˜¡', event)

    if Message_counter == 2:
        text_reply(Message_container, event)

    sheet, bully_names, bully_p, bully_words = bully_reload()

    if user_name in bully_names:
        p = bully_p[bully_names.index(user_name)]
        words = bully_words[bully_names.index(user_name)]
        bully(int(p), words, event)

    with open('previous_user_name.txt', 'w') as f:
        f.write(user_name)


@handler.add(MessageEvent, message=AudioMessage)
def handle_message_Audio(event):
    id = event.source.user_id
    owner = 'U2290158f54f16aea8c2bdb597a54ff9e'
    try:
        group_id = event.source.group_id
    except:
        group_id = 'N/A'

    line_bot_api = LineBotApi(channel_access_token)
    try:
        profile = line_bot_api.get_group_member_profile(
            group_id, id)
    except:
        profile = line_bot_api.get_profile(id)
    user_name = profile.display_name
    # Send To Line
    print(user_name+id)
    F_sound2text(event)


@handler.add(MessageEvent, message=ImageMessage)
def handle_message_Image(event):
    try:
        id = event.source.group_id
    except:
        id = event.source.user_id
    PATH = f'{id}.png'
    image_content = line_bot_api.get_message_content(event.message.id)
    with open(PATH, 'wb') as fd:
        for chunk in image_content.iter_content():
            fd.write(chunk)


@handler.add(PostbackEvent)  # Postbackçš„éƒ¨åˆ†
def handle_postback(event):
    data = event.postback.data
